// Code generated by github.com/varlink/go/cmd/varlink-go-interface-generator, DO NOT EDIT.

// 一个简单的计算器服务
package main

import (
	"context"
	"github.com/varlink/go/varlink"
)

// Generated type declarations

func Dispatch_Error(err error) error {
	if e, ok := err.(*varlink.Error); ok {
		switch e.Name {
		}
	}
	return err
}

// Generated client method calls

type Add_methods struct{}

func Add() Add_methods { return Add_methods{} }

func (m Add_methods) Call(ctx context.Context, c *varlink.Connection, i_in_ int64, j_in_ int64) (rc_out_ int64, err_ error) {
	receive, err_ := m.Send(ctx, c, 0, i_in_, j_in_)
	if err_ != nil {
		return
	}
	rc_out_, _, err_ = receive(ctx)
	return
}

func (m Add_methods) Send(ctx context.Context, c *varlink.Connection, flags uint64, i_in_ int64, j_in_ int64) (func(ctx context.Context) (int64, uint64, error), error) {
	var in struct {
		I int64 `json:"i"`
		J int64 `json:"j"`
	}
	in.I = i_in_
	in.J = j_in_
	receive, err := c.Send(ctx, "top.jouyouyun.calculator1.Add", in, flags)
	if err != nil {
		return nil, err
	}
	return func(context.Context) (rc_out_ int64, flags uint64, err error) {
		var out struct {
			Rc int64 `json:"rc"`
		}
		flags, err = receive(ctx, &out)
		if err != nil {
			err = Dispatch_Error(err)
			return
		}
		rc_out_ = out.Rc
		return
	}, nil
}

func (m Add_methods) Upgrade(ctx context.Context, c *varlink.Connection, i_in_ int64, j_in_ int64) (func(ctx context.Context) (rc_out_ int64, flags uint64, conn varlink.ReadWriterContext, err_ error), error) {
	var in struct {
		I int64 `json:"i"`
		J int64 `json:"j"`
	}
	in.I = i_in_
	in.J = j_in_
	receive, err := c.Upgrade(ctx, "top.jouyouyun.calculator1.Add", in)
	if err != nil {
		return nil, err
	}
	return func(context.Context) (rc_out_ int64, flags uint64, conn varlink.ReadWriterContext, err error) {
		var out struct {
			Rc int64 `json:"rc"`
		}
		flags, conn, err = receive(ctx, &out)
		if err != nil {
			err = Dispatch_Error(err)
			return
		}
		rc_out_ = out.Rc
		return
	}, nil
}

type Sub_methods struct{}

func Sub() Sub_methods { return Sub_methods{} }

func (m Sub_methods) Call(ctx context.Context, c *varlink.Connection, i_in_ int64, j_in_ int64) (rc_out_ int64, err_ error) {
	receive, err_ := m.Send(ctx, c, 0, i_in_, j_in_)
	if err_ != nil {
		return
	}
	rc_out_, _, err_ = receive(ctx)
	return
}

func (m Sub_methods) Send(ctx context.Context, c *varlink.Connection, flags uint64, i_in_ int64, j_in_ int64) (func(ctx context.Context) (int64, uint64, error), error) {
	var in struct {
		I int64 `json:"i"`
		J int64 `json:"j"`
	}
	in.I = i_in_
	in.J = j_in_
	receive, err := c.Send(ctx, "top.jouyouyun.calculator1.Sub", in, flags)
	if err != nil {
		return nil, err
	}
	return func(context.Context) (rc_out_ int64, flags uint64, err error) {
		var out struct {
			Rc int64 `json:"rc"`
		}
		flags, err = receive(ctx, &out)
		if err != nil {
			err = Dispatch_Error(err)
			return
		}
		rc_out_ = out.Rc
		return
	}, nil
}

func (m Sub_methods) Upgrade(ctx context.Context, c *varlink.Connection, i_in_ int64, j_in_ int64) (func(ctx context.Context) (rc_out_ int64, flags uint64, conn varlink.ReadWriterContext, err_ error), error) {
	var in struct {
		I int64 `json:"i"`
		J int64 `json:"j"`
	}
	in.I = i_in_
	in.J = j_in_
	receive, err := c.Upgrade(ctx, "top.jouyouyun.calculator1.Sub", in)
	if err != nil {
		return nil, err
	}
	return func(context.Context) (rc_out_ int64, flags uint64, conn varlink.ReadWriterContext, err error) {
		var out struct {
			Rc int64 `json:"rc"`
		}
		flags, conn, err = receive(ctx, &out)
		if err != nil {
			err = Dispatch_Error(err)
			return
		}
		rc_out_ = out.Rc
		return
	}, nil
}

type Multiple_methods struct{}

func Multiple() Multiple_methods { return Multiple_methods{} }

func (m Multiple_methods) Call(ctx context.Context, c *varlink.Connection, i_in_ int64, j_in_ int64) (rc_out_ int64, err_ error) {
	receive, err_ := m.Send(ctx, c, 0, i_in_, j_in_)
	if err_ != nil {
		return
	}
	rc_out_, _, err_ = receive(ctx)
	return
}

func (m Multiple_methods) Send(ctx context.Context, c *varlink.Connection, flags uint64, i_in_ int64, j_in_ int64) (func(ctx context.Context) (int64, uint64, error), error) {
	var in struct {
		I int64 `json:"i"`
		J int64 `json:"j"`
	}
	in.I = i_in_
	in.J = j_in_
	receive, err := c.Send(ctx, "top.jouyouyun.calculator1.Multiple", in, flags)
	if err != nil {
		return nil, err
	}
	return func(context.Context) (rc_out_ int64, flags uint64, err error) {
		var out struct {
			Rc int64 `json:"rc"`
		}
		flags, err = receive(ctx, &out)
		if err != nil {
			err = Dispatch_Error(err)
			return
		}
		rc_out_ = out.Rc
		return
	}, nil
}

func (m Multiple_methods) Upgrade(ctx context.Context, c *varlink.Connection, i_in_ int64, j_in_ int64) (func(ctx context.Context) (rc_out_ int64, flags uint64, conn varlink.ReadWriterContext, err_ error), error) {
	var in struct {
		I int64 `json:"i"`
		J int64 `json:"j"`
	}
	in.I = i_in_
	in.J = j_in_
	receive, err := c.Upgrade(ctx, "top.jouyouyun.calculator1.Multiple", in)
	if err != nil {
		return nil, err
	}
	return func(context.Context) (rc_out_ int64, flags uint64, conn varlink.ReadWriterContext, err error) {
		var out struct {
			Rc int64 `json:"rc"`
		}
		flags, conn, err = receive(ctx, &out)
		if err != nil {
			err = Dispatch_Error(err)
			return
		}
		rc_out_ = out.Rc
		return
	}, nil
}

type Division_methods struct{}

func Division() Division_methods { return Division_methods{} }

func (m Division_methods) Call(ctx context.Context, c *varlink.Connection, i_in_ int64, j_in_ int64) (rc_out_ int64, err_ error) {
	receive, err_ := m.Send(ctx, c, 0, i_in_, j_in_)
	if err_ != nil {
		return
	}
	rc_out_, _, err_ = receive(ctx)
	return
}

func (m Division_methods) Send(ctx context.Context, c *varlink.Connection, flags uint64, i_in_ int64, j_in_ int64) (func(ctx context.Context) (int64, uint64, error), error) {
	var in struct {
		I int64 `json:"i"`
		J int64 `json:"j"`
	}
	in.I = i_in_
	in.J = j_in_
	receive, err := c.Send(ctx, "top.jouyouyun.calculator1.Division", in, flags)
	if err != nil {
		return nil, err
	}
	return func(context.Context) (rc_out_ int64, flags uint64, err error) {
		var out struct {
			Rc int64 `json:"rc"`
		}
		flags, err = receive(ctx, &out)
		if err != nil {
			err = Dispatch_Error(err)
			return
		}
		rc_out_ = out.Rc
		return
	}, nil
}

func (m Division_methods) Upgrade(ctx context.Context, c *varlink.Connection, i_in_ int64, j_in_ int64) (func(ctx context.Context) (rc_out_ int64, flags uint64, conn varlink.ReadWriterContext, err_ error), error) {
	var in struct {
		I int64 `json:"i"`
		J int64 `json:"j"`
	}
	in.I = i_in_
	in.J = j_in_
	receive, err := c.Upgrade(ctx, "top.jouyouyun.calculator1.Division", in)
	if err != nil {
		return nil, err
	}
	return func(context.Context) (rc_out_ int64, flags uint64, conn varlink.ReadWriterContext, err error) {
		var out struct {
			Rc int64 `json:"rc"`
		}
		flags, conn, err = receive(ctx, &out)
		if err != nil {
			err = Dispatch_Error(err)
			return
		}
		rc_out_ = out.Rc
		return
	}, nil
}

// Generated service interface with all methods

type topjouyouyuncalculator1Interface interface {
	Add(ctx context.Context, c VarlinkCall, i_ int64, j_ int64) error
	Sub(ctx context.Context, c VarlinkCall, i_ int64, j_ int64) error
	Multiple(ctx context.Context, c VarlinkCall, i_ int64, j_ int64) error
	Division(ctx context.Context, c VarlinkCall, i_ int64, j_ int64) error
}

// Generated service object with all methods

type VarlinkCall struct{ varlink.Call }

// Generated reply methods for all varlink errors

// Generated reply methods for all varlink methods

func (c *VarlinkCall) ReplyAdd(ctx context.Context, rc_ int64) error {
	var out struct {
		Rc int64 `json:"rc"`
	}
	out.Rc = rc_
	return c.Reply(ctx, &out)
}

func (c *VarlinkCall) ReplySub(ctx context.Context, rc_ int64) error {
	var out struct {
		Rc int64 `json:"rc"`
	}
	out.Rc = rc_
	return c.Reply(ctx, &out)
}

func (c *VarlinkCall) ReplyMultiple(ctx context.Context, rc_ int64) error {
	var out struct {
		Rc int64 `json:"rc"`
	}
	out.Rc = rc_
	return c.Reply(ctx, &out)
}

func (c *VarlinkCall) ReplyDivision(ctx context.Context, rc_ int64) error {
	var out struct {
		Rc int64 `json:"rc"`
	}
	out.Rc = rc_
	return c.Reply(ctx, &out)
}

// Generated dummy implementations for all varlink methods

func (s *VarlinkInterface) Add(ctx context.Context, c VarlinkCall, i_ int64, j_ int64) error {
	return c.ReplyMethodNotImplemented(ctx, "top.jouyouyun.calculator1.Add")
}

func (s *VarlinkInterface) Sub(ctx context.Context, c VarlinkCall, i_ int64, j_ int64) error {
	return c.ReplyMethodNotImplemented(ctx, "top.jouyouyun.calculator1.Sub")
}

func (s *VarlinkInterface) Multiple(ctx context.Context, c VarlinkCall, i_ int64, j_ int64) error {
	return c.ReplyMethodNotImplemented(ctx, "top.jouyouyun.calculator1.Multiple")
}

func (s *VarlinkInterface) Division(ctx context.Context, c VarlinkCall, i_ int64, j_ int64) error {
	return c.ReplyMethodNotImplemented(ctx, "top.jouyouyun.calculator1.Division")
}

// Generated method call dispatcher

func (s *VarlinkInterface) VarlinkDispatch(ctx context.Context, call varlink.Call, methodname string) error {
	switch methodname {
	case "Add":
		var in struct {
			I int64 `json:"i"`
			J int64 `json:"j"`
		}
		err := call.GetParameters(&in)
		if err != nil {
			return call.ReplyInvalidParameter(ctx, "parameters")
		}
		return s.topjouyouyuncalculator1Interface.Add(ctx, VarlinkCall{call}, in.I, in.J)

	case "Sub":
		var in struct {
			I int64 `json:"i"`
			J int64 `json:"j"`
		}
		err := call.GetParameters(&in)
		if err != nil {
			return call.ReplyInvalidParameter(ctx, "parameters")
		}
		return s.topjouyouyuncalculator1Interface.Sub(ctx, VarlinkCall{call}, in.I, in.J)

	case "Multiple":
		var in struct {
			I int64 `json:"i"`
			J int64 `json:"j"`
		}
		err := call.GetParameters(&in)
		if err != nil {
			return call.ReplyInvalidParameter(ctx, "parameters")
		}
		return s.topjouyouyuncalculator1Interface.Multiple(ctx, VarlinkCall{call}, in.I, in.J)

	case "Division":
		var in struct {
			I int64 `json:"i"`
			J int64 `json:"j"`
		}
		err := call.GetParameters(&in)
		if err != nil {
			return call.ReplyInvalidParameter(ctx, "parameters")
		}
		return s.topjouyouyuncalculator1Interface.Division(ctx, VarlinkCall{call}, in.I, in.J)

	default:
		return call.ReplyMethodNotFound(ctx, methodname)
	}
}

// Generated varlink interface name

func (s *VarlinkInterface) VarlinkGetName() string {
	return `top.jouyouyun.calculator1`
}

// Generated varlink interface description

func (s *VarlinkInterface) VarlinkGetDescription() string {
	return `# 一个简单的计算器服务
interface top.jouyouyun.calculator1

method Add(i: int, j: int) -> (rc: int)

method Sub(i :int, j: int) -> (rc: int)

method Multiple(i: int, j: int) -> (rc: int)

method Division(i: int, j: int) -> (rc: int)
`
}

// Generated service interface

type VarlinkInterface struct {
	topjouyouyuncalculator1Interface
}

func VarlinkNew(m topjouyouyuncalculator1Interface) *VarlinkInterface {
	return &VarlinkInterface{m}
}
